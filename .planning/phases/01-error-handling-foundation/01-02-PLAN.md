---
phase: 01-error-handling-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/termdat.jl
  - test/parser/common_tests.jl
autonomous: true

must_haves:
  truths:
    - "Capacity validation (min_generation > capacity) throws ParserError with correct message"
    - "Heat rate validation throws ParserError for zero/negative values"
    - "ParserError shows correct file path and line number in error message"
  artifacts:
    - path: "src/parser/termdat.jl"
      provides: "Thermal plant data parser with correct validation"
      contains: "throw(ParserError"
    - path: "test/parser/common_tests.jl"
      provides: "Tests for validation error handling"
      contains: "ERR-02"
  key_links:
    - from: "termdat.jl validation"
      to: "ParserError struct"
      via: "throw(ParserError(msg, file, line, line))"
      pattern: "ParserError\\("
---

<objective>
Fix ParserError argument order bugs in termdat.jl and add tests to verify capacity/heat rate validation throws ParserError correctly.

Purpose: ERR-02 and ERR-03 validation should work correctly with proper error context.
Output: termdat.jl with correct ParserError calls + tests for error paths.

**Critical Finding:** Research revealed that many ParserError calls in termdat.jl have arguments in WRONG ORDER. The struct expects (msg, file, line, content) but calls use (file, line, content, msg).
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-error-handling-foundation/01-RESEARCH.md

# Reference Implementations
# - idessem: https://github.com/rjmalves/idessem (DESSEM parsing reference)
# - inewave: https://github.com/rjmalves/inewave (NEWAVE parsing reference, related ecosystem)
# - sintetizador-dessem: https://github.com/rjmalves/sintetizador-dessem (synthetic data generator)
#
# These provide patterns for validation error handling.
# Check idessem's validation patterns when implementing ERR-02/ERR-03 tests.

# ParserError struct definition (CORRECT argument order):
# struct ParserError <: Exception
#     msg::String      # FIRST: Error message
#     file::String     # SECOND: File path
#     line::Int        # THIRD: Line number
#     content::String  # FOURTH: Line content
# end

# Correct pattern from common.jl:296-301:
# ParserError(
#     "Required field 'field_name' is missing...",  # msg first
#     file,
#     line_num,
#     line,
# )
</context>

<tasks>

<task type="auto">
  <name>Fix ParserError argument order in termdat.jl</name>
  <files>src/parser/termdat.jl</files>
  <action>
Fix all ParserError calls that have arguments in wrong order.

**Lines with WRONG order (file, line, content, msg):**
- Line 329: `ParserError(file, line_num, line, "Empty CADCONF record")`
- Line 415: `ParserError(file, line_num, line, "Empty CADMIN record")`
- Line 422: `ParserError(file, line_num, line, "Expected CADMIN record...")`

**Lines to verify (may already be correct):**
- Lines 72, 187, 206, 295, 336, 347, 360, 373, 386, 441, 454, 467, 543

**Correct pattern:**
```julia
# BEFORE (WRONG):
ParserError(file, line_num, line, "Error message")

# AFTER (CORRECT):
ParserError("Error message", file, line_num, line)
```

**Line 206-212 (capacity validation) - verify this is correct:**
```julia
throw(
    ParserError(
        file,        # WRONG - should be msg
        line_num,    # WRONG - should be file
        line,        # WRONG - should be line_num
        "Minimum generation ($(data.min_generation) MW) exceeds unit capacity ($(data.unit_capacity) MW)",
    ),
)
```

Should become:
```julia
throw(
    ParserError(
        "Minimum generation ($(data.min_generation) MW) exceeds unit capacity ($(data.unit_capacity) MW)",
        file,
        line_num,
        line,
    ),
)
```

Scan entire file and fix ALL instances where arguments are in wrong order.
  </action>
  <verify>
# Verify no ParserError calls have file as first string argument
grep -n "ParserError(" src/parser/termdat.jl | head -20
# Then manually verify the error message appears FIRST in each call
  </verify>
  <done>All ParserError calls in termdat.jl have correct argument order (msg, file, line, content)</done>
</task>

<task type="auto">
  <name>Add capacity validation tests (ERR-02)</name>
  <files>test/parser/common_tests.jl</files>
  <action>
Add test cases for capacity validation in termdat.jl.

Add to existing test file or create new section:
```julia
@testset "ERR-02: Capacity Validation" begin
    @testset "Throws ParserError when min_generation > capacity" begin
        # Create a line with min_generation > unit_capacity
        invalid_line = "CADUNIDT 001 001 USINA-TESTE 001 100.0 200.0 0 0 0 0 0 0 0 0"
        # min_generation (200.0) > unit_capacity (100.0)
        
        @test_throws ParserError parse_cadunidt_line(invalid_line, "test.dat", 1)
        
        # Verify error contains proper context
        try
            parse_cadunidt_line(invalid_line, "test.dat", 42)
        catch e
            @test isa(e, ParserError)
            @test occursin("Minimum generation", e.msg)
            @test occursin("exceeds unit capacity", e.msg)
            @test e.file == "test.dat"
            @test e.line == 42
        end
    end
    
    @testset "Does NOT throw MethodError for capacity validation" begin
        # Verify we get ParserError, not MethodError
        invalid_line = "CADUNIDT 001 001 USINA-TESTE 001 100.0 200.0 0 0 0 0 0 0 0 0"
        
        try
            parse_cadunidt_line(invalid_line, "test.dat", 1)
            @test false  # Should not reach here
        catch e
            @test !isa(e, MethodError)
            @test isa(e, ParserError)
        end
    end
end
```

Note: Adjust the line format to match actual CADUNIDT format in termdat.jl.
  </action>
  <verify>julia --project -e 'using Pkg; Pkg.test()' passes including new tests</verify>
  <done>Tests verify capacity validation throws ParserError (not MethodError) with correct context</done>
</task>

<task type="auto">
  <name>Add heat rate validation tests (ERR-03)</name>
  <files>test/parser/common_tests.jl</files>
  <action>
Add test cases for heat rate validation.

```julia
@testset "ERR-03: Heat Rate Validation" begin
    @testset "Throws ParserError for zero heat_rate" begin
        # Create a line with heat_rate = 0
        # Need to find the correct record type and format
        
        @test_throws ParserError parse_heat_rate_record(zero_heat_rate_line, "test.dat", 1)
    end
    
    @testset "Throws ParserError for negative heat_rate" begin
        # Create a line with heat_rate < 0
        
        @test_throws ParserError parse_heat_rate_record(negative_heat_rate_line, "test.dat", 1)
    end
    
    @testset "Heat rate validation error includes context" begin
        try
            parse_heat_rate_record(invalid_line, "test.dat", 42)
        catch e
            @test isa(e, ParserError)
            @test e.file == "test.dat"
            @test e.line == 42
        end
    end
end
```

Note: Adjust record type and format to match actual termdat.jl heat rate parsing.
  </action>
  <verify>julia --project -e 'using Pkg; Pkg.test()' passes including new tests</verify>
  <done>Tests verify heat rate validation throws ParserError for zero/negative values</done>
</task>

</tasks>

<verification>
1. Run tests: `julia --project -e 'using Pkg; Pkg.test()'`
2. Verify capacity validation error message appears correctly formatted:
   ```julia
   # In REPL:
   using DESSEM2Julia
   # Try parsing invalid data and verify error message shows file:line
   ```
3. Check that ParserError.msg contains the actual message (not a file path)
</verification>

<success_criteria>
- All ParserError calls in termdat.jl have correct argument order
- Capacity validation (min > capacity) throws ParserError with descriptive message
- Heat rate validation throws ParserError for invalid values
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-handling-foundation/01-02-SUMMARY.md`
</output>
