---
phase: 01-error-handling-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/simul.jl
  - src/parser/renovaveis.jl
  - src/parser/operut.jl
  - src/parser/dadvaz.jl
  - src/parser/desselet.jl
  - src/parser/cortdeco.jl
  - src/parser/hidr_binary.jl
  - src/parser/pwf.jl
autonomous: true

must_haves:
  truths:
    - "All error() calls replaced with throw(ParserError(...))"
    - "ParserError includes file path, line number, and line content"
    - "No parser throws generic ErrorException"
  artifacts:
    - path: "src/parser/pwf.jl"
      provides: "Network file parser with ParserError handling"
      contains: "throw(ParserError"
    - path: "src/parser/renovaveis.jl"
      provides: "Renewables parser with ParserError handling"
      contains: "throw(ParserError"
    - path: "src/parser/simul.jl"
      provides: "Legacy SIMUL parser with ParserError handling"
      contains: "throw(ParserError"
  key_links:
    - from: "error() call sites"
      to: "ParserError struct"
      via: "throw(ParserError(msg, file, line_num, line))"
      pattern: "throw\\(ParserError\\("
---

<objective>
Replace all error() calls with throw(ParserError(...)) across 8 parser files to ensure consistent exception handling.

Purpose: Users should catch ParserError (not ErrorException) for all parsing failures, with file/line context.
Output: 8 parser files using ParserError consistently.

**Critical Note:** This plan also handles pwf.jl @warn patterns (lines 198, 213) to avoid file ownership conflicts with other plans.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-error-handling-foundation/01-RESEARCH.md

# ParserError struct definition (correct argument order)
# struct ParserError <: Exception
#     msg::String      # FIRST: Error message
#     file::String     # SECOND: File path
#     line::Int        # THIRD: Line number
#     content::String  # FOURTH: Line content
# end
</context>

<tasks>

<task type="auto">
  <name>Replace error() calls in simul.jl</name>
  <files>src/parser/simul.jl</files>
  <action>
Replace 5 error() calls (lines 69, 109, 135, 218, 299) with throw(ParserError(...)).

Pattern transformation:
```julia
# BEFORE:
error("Error parsing SIMUL header at $filename:$line_num: $e\nLine: '$line'")

# AFTER:
if isa(e, ParserError)
    rethrow(e)
else
    throw(ParserError("Error parsing SIMUL header: $(sprint(showerror, e))", filename, line_num, line))
end
```

Line 299 (no catch block, just validation):
```julia
# BEFORE:
error("SIMUL file $filename does not contain a valid header (Record 3)")

# AFTER:
throw(ParserError("SIMUL file does not contain a valid header (Record 3)", filename, line_num, ""))
```

CRITICAL: ParserError argument order is (msg, file, line, content) - message FIRST.
  </action>
  <verify>grep -c "error(" src/parser/simul.jl returns 0</verify>
  <done>All error() calls in simul.jl replaced with throw(ParserError(...))</done>
</task>

<task type="auto">
  <name>Replace error() calls in renovaveis.jl</name>
  <files>src/parser/renovaveis.jl</files>
  <action>
Replace 5 error() calls (lines 82, 90, 147, 184, 227) with throw(ParserError(...)).

For catch blocks, use the rethrow pattern:
```julia
catch e
    if isa(e, ParserError)
        rethrow(e)
    else
        throw(ParserError("Descriptive message: $(sprint(showerror, e))", filename, line_num, line))
    end
end
```

For validation errors (line 90):
```julia
# BEFORE:
error("Line $line_num in $filename: Expected 'EOLICA', got '$record_type'")

# AFTER:
throw(ParserError("Expected 'EOLICA', got '$record_type'", filename, line_num, line))
```

CRITICAL: ParserError argument order is (msg, file, line, content).
  </action>
  <verify>grep -c "error(" src/parser/renovaveis.jl returns 0</verify>
  <done>All error() calls in renovaveis.jl replaced with throw(ParserError(...))</done>
</task>

<task type="auto">
  <name>Replace error() calls and fix helpers in operut.jl</name>
  <files>src/parser/operut.jl</files>
  <action>
1. Replace local helper functions (lines 16, 22) to use ParserCommon or throw ParserError:

```julia
# BEFORE (lines 14-24):
function parse_int(s::AbstractString)
    s_clean = strip(s)
    isempty(s_clean) && error("Cannot parse empty string as Int")
    return parse(Int, s_clean)
end

function parse_float(s::AbstractString)
    s_clean = strip(s)
    isempty(s_clean) && error("Cannot parse empty string as Float64")
    return parse(Float64, s_clean)
end

# OPTION A: Import and use ParserCommon.parse_int, ParserCommon.parse_float
# OPTION B: Make helpers throw ParserError (but they don't have file context)
```

Best approach: Import ParserCommon helpers which already handle ParserError:
```julia
using ..ParserCommon: parse_int, parse_float  # If not already imported
```

Or if local helpers are truly needed, remove the error() calls and let parse() throw naturally ( ArgumentError), then catch and wrap in caller.

2. Remove local error() calls, rely on ParserCommon or natural parse() exceptions.
  </action>
  <verify>grep -c "error(" src/parser/operut.jl returns 0</verify>
  <done>operut.jl uses ParserCommon helpers or throws ParserError for parse failures</done>
</task>

<task type="auto">
  <name>Replace error() calls in dadvaz.jl</name>
  <files>src/parser/dadvaz.jl</files>
  <action>
Replace ~14 error() calls with throw(ParserError(...)).

These are mostly validation checks (lines 57-199):
```julia
# BEFORE:
start_day === nothing && error("Missing start day in DADVAZ record")

# AFTER:
start_day === nothing && throw(ParserError("Missing start day in DADVAZ record", filename, line_num, line))
```

For the header parsing section, ensure filename and line context are available. Pass them through function arguments if needed.

CRITICAL: ParserError argument order is (msg, file, line, content).
  </action>
  <verify>grep -c "error(" src/parser/dadvaz.jl returns 0</verify>
  <done>All error() calls in dadvaz.jl replaced with throw(ParserError(...))</done>
</task>

<task type="auto">
  <name>Replace error() calls in desselet.jl</name>
  <files>src/parser/desselet.jl</files>
  <action>
Replace 3 error() calls (lines 38, 68, 78) with throw(ParserError(...)).

```julia
# BEFORE:
error("Invalid base case line at $line_num: requires at least 3 fields")

# AFTER:
throw(ParserError("Invalid base case line: requires at least 3 fields", filename, line_num, line))
```

CRITICAL: ParserError argument order is (msg, file, line, content).
  </action>
  <verify>grep -c "error(" src/parser/desselet.jl returns 0</verify>
  <done>All error() calls in desselet.jl replaced with throw(ParserError(...))</done>
</task>

<task type="auto">
  <name>Replace error() calls in cortdeco.jl</name>
  <files>src/parser/cortdeco.jl</files>
  <action>
Replace 4 error() calls (lines 134, 309, 318, 322) with throw(ParserError(...)).

These include validation errors for FCF cuts:
```julia
# BEFORE:
error("UHE code $uhe_code not found in FCF cuts. Available: $(cuts.codigos_uhes)")

# AFTER:
throw(ParserError("UHE code $uhe_code not found in FCF cuts. Available: $(cuts.codigos_uhes)", filename, line_num, line))
```

CRITICAL: ParserError argument order is (msg, file, line, content).
  </action>
  <verify>grep -c "error(" src/parser/cortdeco.jl returns 0</verify>
  <done>All error() calls in cortdeco.jl replaced with throw(ParserError(...))</done>
</task>

<task type="auto">
  <name>Replace error() call in hidr_binary.jl</name>
  <files>src/parser/hidr_binary.jl</files>
  <action>
Replace 1 error() call (line 211):

```julia
# BEFORE:
error("File not found: $filepath")

# AFTER:
throw(ParserError("File not found: $filepath", filepath, 0, ""))
```

Note: For file not found, line number is 0 and content is empty.
  </action>
  <verify>grep -c "error(" src/parser/hidr_binary.jl returns 0</verify>
  <done>error() call in hidr_binary.jl replaced with throw(ParserError(...))</done>
</task>

<task type="auto">
  <name>Replace error() and @warn calls in pwf.jl</name>
  <files>src/parser/pwf.jl</files>
  <action>
Replace 4 error() calls (lines 100, 266, 360, 370) AND 2 @warn patterns (lines 198, 213).

**error() replacements:**
```julia
# Line 100 - catch block:
# BEFORE:
error("Failed to parse PWF file '$filepath': $e")

# AFTER:
if isa(e, ParserError)
    rethrow(e)
else
    throw(ParserError("Failed to parse PWF file: $(sprint(showerror, e))", filepath, 0, ""))
end
```

**@warn replacements (lines 198, 213):**
```julia
# BEFORE:
@warn "Failed to convert bus data" bus_data exception = e

# AFTER:
if isa(e, ParserError)
    rethrow(e)
else
    throw(ParserError("Failed to convert bus data: $(sprint(showerror, e))", filepath, line_num, string(bus_data)))
end
```

CRITICAL: 
- ParserError argument order is (msg, file, line, content)
- Remove @warn + continue patterns - they must throw instead
  </action>
  <verify>
grep -c "error(" src/parser/pwf.jl returns 0
grep -c "@warn" src/parser/pwf.jl returns 0
  </verify>
  <done>All error() and @warn calls in pwf.jl replaced with throw(ParserError(...))</done>
</task>

</tasks>

<verification>
1. Run `grep -r "error(" src/parser/*.jl | grep -v "ParserError" | grep -v "showerror"` - should return empty
2. Run `julia --project -e 'using Pkg; Pkg.test()'` - all tests should pass
3. Verify error messages include file path and line number when parsing fails
</verification>

<success_criteria>
- Zero error() calls in modified parser files (except ParserError/showerror)
- All parsers throw ParserError with file/line context
- Existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-handling-foundation/01-01-SUMMARY.md`
</output>
