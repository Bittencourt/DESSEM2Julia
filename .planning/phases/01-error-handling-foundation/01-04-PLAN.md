---
phase: 01-error-handling-foundation
plan: 04
type: execute
wave: 2
depends_on:
  - 01-01A
  - 01-01B
  - 01-01C
  - 01-02
  - 01-03
files_modified:
  - test/parser/error_handling_tests.jl
  - test/parser/common_tests.jl
  - test/runtests.jl
autonomous: true

must_haves:
  truths:
    - "Test suite verifies all parsers throw ParserError (not MethodError/ErrorException)"
    - "Test suite verifies ParserError contains file path and line number"
    - "Test suite covers capacity validation error path"
    - "Test suite covers heat rate validation error path"
    - "Test suite covers silent failure elimination in operuh.jl"
  artifacts:
    - path: "test/parser/error_handling_tests.jl"
      provides: "Centralized error path tests"
      exports: ["ErrorHandling", "ParserError"]
    - path: "test/runtests.jl"
      provides: "Test runner including error handling tests"
      contains: "error_handling_tests"
  key_links:
    - from: "Error handling tests"
      to: "All parser files"
      via: "@test_throws ParserError"
      pattern: "@test_throws ParserError"
---

<objective>
Create comprehensive error path tests to verify all parsers throw ParserError with proper context.

Purpose: DEBT-08 - Ensure error paths are tested and future regressions are caught.
Output: Test file verifying error handling across all parsers.

This plan runs AFTER Plans 01-01, 01-02, and 01-03 have fixed the error handling.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-error-handling-foundation/01-RESEARCH.md

# Test infrastructure location:
# test/runtests.jl - Main test runner
# test/parser/common_tests.jl - Common parser tests
# test/parser/*_tests.jl - Individual parser tests
</context>

<tasks>

<task type="auto">
  <name>Create error_handling_tests.jl</name>
  <files>test/parser/error_handling_tests.jl</files>
  <action>
Create new test file for error handling verification.

```julia
@testset "Error Handling - Phase 1" begin
    
    @testset "ParserError Structure" begin
        @testset "Contains required fields" begin
            err = ParserError("Test message", "test.dat", 42, "test line content")
            @test err.msg == "Test message"
            @test err.file == "test.dat"
            @test err.line == 42
            @test err.content == "test line content"
        end
        
        @testset "Formatted output includes context" begin
            err = ParserError("Test error", "test.dat", 42, "problematic line")
            io = IOBuffer()
            showerror(io, err)
            msg = String(take!(io))
            @test occursin("test.dat:42", msg)
            @test occursin("Test error", msg)
            @test occursin("problematic line", msg)
        end
    end
    
    @testset "ERR-01: All parsers use ParserError" begin
        # Verify no parser throws generic error() or ArgumentError
        # This is a contract test - parsers should throw ParserError
        
        @testset "No MethodError from capacity validation" begin
            # When min_generation > capacity, should get ParserError not MethodError
            # (Tested in detail in ERR-02 tests)
        end
    end
    
    @testset "ERR-02: Capacity Validation" begin
        @testset "min_generation > capacity throws ParserError" begin
            # Create test data where min > capacity
            # Actual implementation depends on termdat.jl structure
            
            # Test that error is ParserError, not MethodError
            # Test that error includes file and line context
        end
    end
    
    @testset "ERR-03: Heat Rate Validation" begin
        @testset "Zero heat_rate throws ParserError" begin
            # Test heat rate = 0 case
        end
        
        @testset "Negative heat_rate throws ParserError" begin
            # Test heat rate < 0 case
        end
    end
    
    @testset "ERR-04: Silent Failures Eliminated" begin
        @testset "operuh.jl throws ParserError on invalid input" begin
            # Test that invalid REST, ELEM, LIM, VAR records throw
            # (not return nothing silently)
        end
    end
    
    @testset "Parser Error Context" begin
        @testset "File path included in error" begin
            # All ParserError throws should include file path
        end
        
        @testset "Line number included in error" begin
            # All ParserError throws should include line number
        end
        
        @testset "Line content included in error" begin
            # All ParserError throws should include problematic line
        end
    end
end
```

Fill in concrete test implementations based on actual parser structures.
  </action>
  <verify>
test -f test/parser/error_handling_tests.jl
grep -c "@testset" test/parser/error_handling_tests.jl
  </verify>
  <done>error_handling_tests.jl created with comprehensive error path tests</done>
</task>

<task type="auto">
  <name>Add specific parser error tests</name>
  <files>test/parser/error_handling_tests.jl</files>
  <action>
Add concrete tests for each parser that was modified:

**simul.jl tests:**
```julia
@testset "simul.jl error handling" begin
    @testset "Invalid header throws ParserError" begin
        # Create invalid header content
        # @test_throws ParserError parse_simul(invalid_content, "test.simul")
    end
end
```

**pwf.jl tests:**
```julia
@testset "pwf.jl error handling" begin
    @testset "Missing bus number throws ParserError" begin
        # @test_throws ParserError parse_pwf_bus(missing_bus_line, "test.pwf", 1)
    end
    
    @testset "Invalid branch data throws ParserError" begin
        # @test_throws ParserError parse_pwf_branch(invalid_branch, "test.pwf", 1)
    end
end
```

**operuh.jl tests:**
```julia
@testset "operuh.jl error handling" begin
    @testset "Invalid REST record throws ParserError" begin
        invalid_rest = "INVALID REST DATA HERE"
        # @test_throws ParserError parse_operuh_rest(invalid_rest, "test.dat", 1)
        
        # Verify we DON'T get nothing returned
        result = try
            parse_operuh_rest(invalid_rest, "test.dat", 1)
        catch e
            e
        end
        @test result !== nothing
        @test isa(result, ParserError)
    end
    
    # Similar tests for ELEM, LIM, VAR records
end
```

**renovaveis.jl tests:**
```julia
@testset "renovaveis.jl error handling" begin
    @testset "Invalid record type throws ParserError" begin
        # @test_throws ParserError parse_renovaveis(wrong_type_line, "test.dat", 1)
    end
end
```

Implement concrete tests based on actual parser function signatures.
  </action>
  <verify>grep -c "@test_throws ParserError" test/parser/error_handling_tests.jl returns at least 5</verify>
  <done>Concrete error tests added for all modified parsers</done>
</task>

<task type="auto">
  <name>Include error_handling_tests in runtests.jl</name>
  <files>test/runtests.jl</files>
  <action>
Add the new error_handling_tests.jl to the test runner.

```julia
# In test/runtests.jl, add:
include("parser/error_handling_tests.jl")
```

Place it after common_tests.jl but before other parser-specific tests.
  </action>
  <verify>grep -c "error_handling_tests" test/runtests.jl returns 1</verify>
  <done>error_handling_tests.jl included in test suite</done>
</task>

<task type="auto">
  <name>Run full test suite and verify</name>
  <files>test/parser/error_handling_tests.jl</files>
  <action>
Run the complete test suite and verify all error handling tests pass.

```bash
julia --project -e 'using Pkg; Pkg.test()'
```

If any tests fail:
1. Check that Plans 01-01, 01-02, 01-03 have been executed
2. Verify test expectations match actual parser behavior
3. Fix test implementations (not the parsers - those should be correct)
  </action>
  <verify>julia --project -e 'using Pkg; Pkg.test()' exits with code 0</verify>
  <done>All tests pass including new error handling tests</done>
</task>

</tasks>

<verification>
1. Run `julia --project -e 'using Pkg; Pkg.test()'` - all tests pass
2. Verify error handling tests are executed (check test output for "Error Handling - Phase 1")
3. Count: at least 10 @test statements in error_handling_tests.jl
4. Count: at least 5 @test_throws ParserError statements
</verification>

<success_criteria>
- error_handling_tests.jl exists and runs
- All error handling tests pass
- Test coverage for ERR-01, ERR-02, ERR-03, ERR-04
- Tests verify ParserError has file/line/content context
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-handling-foundation/01-04-SUMMARY.md`
</output>
